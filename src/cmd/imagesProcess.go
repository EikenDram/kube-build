package cmd

import (
	"fmt"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

// images.yaml
var fileProcessImage string = "deployment/images.yaml"

// imageCmd represents the image command
var imageProcessCmd = &cobra.Command{
	Use:   "process",
	Short: "Processes images.yaml generated by script",
	Long: `Processes images.yaml file generated by script
	in deployment directory`,
	Run: func(cmd *cobra.Command, args []string) {
		imageProcess()
	},
}

func init() {
	imageCmd.AddCommand(imageProcessCmd)
	imageProcessCmd.Flags().StringVar(&fileProcessImage, "file", "images.yaml", "Yaml file with images generated with script")
}

// loaded map from images.yaml
var img = make(map[string]interface{})

func readImg() {
	//read images from images.yaml
	yamlImg, err := os.ReadFile(fileProcessImage)
	check(err)

	err = yaml.Unmarshal([]byte(yamlImg), &img)
	check(err)
}

// url structure
type UrlParse struct {
	url     string
	host    string
	path    string
	name    string
	version string
	sha     string
	args    string
}

func imageProcess() {
	// read images.yaml
	readImg()

	//m := make(map[string][]UrlParse)
	f, err := os.Create(fileProcessImage)
	check(err)
	f.WriteString("### THIS FILE IS AUTO-GENERATED BY BUILD IMAGE PROCESS COMMAND ###")

	//order keys in yaml
	keys := make([]string, 0, len(img))
	for k := range img {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// iterate through all values
	for _, key := range keys {
		value := img[key]
		if value != nil {
			f.WriteString("\n")
			f.WriteString(fmt.Sprintf("%s:", key) + "\n")

			for _, i := range value.([]interface{}) {
				if i != nil {
					for k, v := range i.(map[string]interface{}) {
						if k == "url" {
							p := parseUrl(v.(string))
							f.WriteString(fmt.Sprintf("- url: %s", p.url) + "\n")
							f.WriteString(fmt.Sprintf("  host: %s", p.host) + "\n")
							f.WriteString(fmt.Sprintf("  path: %s", p.path) + "\n")
							f.WriteString(fmt.Sprintf("  name: %s", p.name) + "\n")
							f.WriteString(fmt.Sprintf("  version: %s", p.version) + "\n")
							if len(p.sha) > 0 {
								f.WriteString(fmt.Sprintf("  sha: %s", p.sha) + "\n")
							}
							if len(p.args) > 0 {
								f.WriteString(fmt.Sprintf("  args: %s", p.args) + "\n")
							}
						}
					}
				}
			}
		}
	}
}

// parses url into {host}/{path}/{name}:{version}
func parseUrl(url string) UrlParse {
	var res UrlParse

	// 1. remove args if exist
	s := strings.Split(url, "@args:")
	if len(s) > 1 {
		url = s[0]
		res.args = s[1]
	}

	// 2. remove sha if exists
	s = strings.Split(url, "@sha256:")
	if len(s) > 1 {
		url = s[0]
		res.sha = s[1]
	}
	// 3. split tag
	s = strings.Split(url, ":")
	var path string
	switch c := len(s); {
	case c == 2:
		//there's a tag
		res.version = s[1]
		path = s[0]
	case c > 2:
		//multiple tags? let's panic
		panic("shouldn't be multiple tags in url")
	case c == 1:
		//there's no tag
		res.version = "latest"
		path = url
	}

	//4. split path
	s = strings.Split(path, "/")
	switch c := len(s); {
	case c == 1:
		//no subpaths in path
		//gonna default to docker.io/library
		res.host = "docker.io"
		res.path = "library"
		res.name = path
	case c > 1:
		//one or more subpath in path
		//final one shall be name
		res.name = s[len(s)-1]

		var i int = 0
		//need to check what's the first subpath
		if strings.Contains(s[0], ".") {
			// first element contains a dot (.), we'll assume it's the host
			res.host = s[0]
			// and start recombining path from 1st element
			i = 1
		} else {
			// no dot
			// gonna default to docker.io host
			res.host = "docker.io"
		}

		//check if we have any path left
		if i < len(s)-1 {
			//recombine
			for k := i; k < len(s)-1; k++ {
				res.path += s[k] + "/"
			}
			//remove last /
			res.path = strings.TrimSuffix(res.path, "/")
		} else {
			//first element was host and last one was name, and no other elements
			//gonna default path to library then
			res.path = "library"
		}
	}

	res.url = fmt.Sprintf("%s/%s/%s:%s", res.host, res.path, res.name, res.version)

	log.Println("Processed url: ", url)
	log.Println("     host: ", res.host)
	log.Println("     path: ", res.path)
	log.Println("     name: ", res.name)
	log.Println("  version: ", res.version)
	if len(res.sha) > 0 {
		log.Println("      sha: ", res.sha)
	}
	if len(res.args) > 0 {
		log.Println("     args: ", res.args)
	}

	return res
}
